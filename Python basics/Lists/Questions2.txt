1).
Greatest Common Divisor
Problem Introduction
The greatest common divisor GCD(ğ‘,ğ‘) of two non-negative integers ğ‘ and ğ‘ (which are not both equal to 0) is the greatest integer ğ‘‘ that divides both ğ‘ and ğ‘. Your goal in this problem is to implement the Euclidean algorithm for computing the greatest common divisor.
Efficient algorithm for computing the greatest common divisor is an important basic primitive of commonly used cryptographic algorithms like RSA.
Problem Description
Task. Given two integers ğ‘ and ğ‘, find their greatest common divisor.
Input Format.

The two integers ğ‘, ğ‘ are given in the same line separated by space. Constraints. 1â‰¤ğ‘,ğ‘â‰¤2Â·109.

Output Format. 
Output GCD(ğ‘, ğ‘).

Sample 1.
Input:
18 35

Output:
1

Hint
18 and 35 do not have common non-trivial divisors.


Sample 2.
Input:
28851538 1183019

Output:
17657

Hint
28851538 = 17657 Â· 1634, 1183019 = 17657 Â· 67.


2).
Last Digit of a Large Fibonacci Number
Problem Introduction
Your goal in this problem is to find the last digit of ğ‘›-th Fibonacci number. Recall that Fibonacci numbers grow exponentially fast. For example,
ğ¹200 = 280571172992510140037611932413038677189525. Therefore, a solution like
will turn out to be too slow, because as ğ‘– grows the ğ‘–th iteration of the loop computes the sum of longer and longer numbers. Also, for example, ğ¹1000 does not fit into the standard C++ int type. To overcome this difficulty, you may want to store in ğ¹[ğ‘–] not the ğ‘–th Fibonacci number itself, but just its last digit (that is, ğ¹ğ‘– mod 10). Computing the last digit of ğ¹ğ‘– is easy: it is just the last digit of the sum of the last digits of ğ¹ğ‘–âˆ’1 and ğ¹ğ‘–âˆ’2:
ğ¹ [ğ‘–] â† (ğ¹ [ğ‘– âˆ’ 1] + ğ¹ [ğ‘– âˆ’ 2]) mod 10
This way, all ğ¹[ğ‘–]â€™s are just digits, so they fit perfectly into any standard integer type, and computing a sum
of ğ¹ [ğ‘– âˆ’ 1] and ğ¹ [ğ‘– âˆ’ 2] is performed very quickly.
Problem Description
Task. Given an integer ğ‘›, find the last digit of the ğ‘›th Fibonacci number ğ¹ğ‘› (that is, ğ¹ğ‘› mod 10). 
Input Format.
The input consists of a single integer ğ‘›.

Constraints. 0 â‰¤ ğ‘› â‰¤ 107.

Output Format. 
Output the last digit of ğ¹ğ‘›.

Sample 1.
Input:
3
Output:
2
ğ¹3 = 2.

Sample 2.
Input:
331
Output:
9

HINT
ğ¹331 =668996615388005031531000081241745415306766517246774551964595292186469.
ğ¹[0] â† 0
ğ¹[1] â† 1
for ğ‘– from 2 to ğ‘›:
ğ¹ [ğ‘–] â† ğ¹ [ğ‘– âˆ’ 1] + ğ¹ [ğ‘– âˆ’ 2] print(ğ¹[ğ‘›] mod 10)
4


Sample 3.
Input:
327305

Output:
5

HINT
ğ¹327305 does not fit into one line of this pdf, but its last digit is equal to 5.


3).
Money Change
Problem Description
Task. The goal in this problem is to find the minimum number of coins needed to change the input value (an integer) into coins with denominations 1, 5, and 10.
Input Format. 
The input consists of a single integer ğ‘š.
Constraints. 1 â‰¤ ğ‘š â‰¤ 103.

Output Format. 
Output the minimum number of coins with denominations 1, 5, 10 that changes ğ‘š.

Sample 1.
Input:
2
Output:
2

solution  2 = 1 + 1.


Sample 2.
Input:
28
Output:
6

solution  28 = 10 + 10 + 5 + 1 + 1 + 1.